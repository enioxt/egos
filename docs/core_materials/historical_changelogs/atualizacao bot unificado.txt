Entendo que precisamos criar o script `setup_unified_bot.py` de forma gradual e modular, dividindo o trabalho em etapas para garantir qualidade e precis√£o. Vamos come√ßar com a estrutura b√°sica do arquivo e depois expandir cada m√≥dulo.

Primeiro, vou criar o arquivo com a estrutura inicial e as importa√ß√µes necess√°rias:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
EVA & GUARANI - Setup do Bot Unificado
--------------------------------------
Script para configura√ß√£o e instala√ß√£o do Bot Telegram Unificado EVA & GUARANI.
Este script verifica e configura todos os componentes necess√°rios para o funcionamento do bot.

Vers√£o: 1.0.0
"""

import os
import sys
import json
import shutil
import logging
import platform
import subprocess
import datetime
from pathlib import Path
from typing import Dict, Any, List, Optional, Tuple, Union

# Configura√ß√£o de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("logs/setup.log", mode='a'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

# Constantes
CONFIG_DIR = "config"
DATA_DIR = "data"
LOGS_DIR = "logs"
MODULES_DIR = "modules"
INTEGRATION_DIR = os.path.join(MODULES_DIR, "integration")
REQUIREMENTS_FILE = "requirements.txt"
ENV_FILE = ".env"
BOT_CONFIG_FILE = os.path.join(CONFIG_DIR, "bot_config.json")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verifica√ß√µes e configura√ß√µes ser√£o adicionadas aqui

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

# Fun√ß√£o para exibir o cabe√ßalho
def print_header():
    """Exibe o cabe√ßalho do script."""
    print("\n" + "=" * 50)
    print("EVA & GUARANI - Setup do Bot Unificado")
    print("Vers√£o: 1.0.0")
    print("=" * 50 + "\n")

if __name__ == "__main__":
    sys.exit(main())
```


√ìtimo! Agora vamos adicionar a primeira fun√ß√£o modular para verificar e criar os diret√≥rios necess√°rios:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

# Constantes
CONFIG_DIR = "config"
DATA_DIR = "data"
LOGS_DIR = "logs"
MODULES_DIR = "modules"
INTEGRATION_DIR = os.path.join(MODULES_DIR, "integration")
REQUIREMENTS_FILE = "requirements.txt"
ENV_FILE = ".env"
BOT_CONFIG_FILE = os.path.join(CONFIG_DIR, "bot_config.json")

def check_directories() -> bool:
    """
    Verifica e cria os diret√≥rios necess√°rios para o funcionamento do bot.

    Returns:
        bool: True se todos os diret√≥rios foram verificados/criados com sucesso, False caso contr√°rio.
    """
    directories = [
        CONFIG_DIR,
        DATA_DIR,
        LOGS_DIR,
        MODULES_DIR,
        INTEGRATION_DIR,
        os.path.join(DATA_DIR, "images"),
        os.path.join(DATA_DIR, "consciousness"),
        os.path.join(DATA_DIR, "conversations"),
        os.path.join(DATA_DIR, "backups"),
        os.path.join(MODULES_DIR, "mycelium"),
        os.path.join(MODULES_DIR, "quantum")
    ]

    logger.info("Verificando diret√≥rios necess√°rios...")

    try:
        for directory in directories:
            if not os.path.exists(directory):
                logger.info(f"Criando diret√≥rio: {directory}")
                os.makedirs(directory, exist_ok=True)
                print(f"üìÅ Diret√≥rio criado: {directory}")
            else:
                logger.debug(f"Diret√≥rio j√° existe: {directory}")

        print("‚úÖ Todos os diret√≥rios necess√°rios est√£o dispon√≠veis.")
        return True
    except Exception as e:
        logger.error(f"Erro ao verificar/criar diret√≥rios: {e}")
        print(f"‚ùå Erro ao verificar/criar diret√≥rios: {e}")
        return False

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Outras verifica√ß√µes e configura√ß√µes ser√£o adicionadas aqui

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```


Agora vamos adicionar a fun√ß√£o para verificar e configurar o ambiente Python, incluindo a verifica√ß√£o da vers√£o do Python e a cria√ß√£o de um ambiente virtual:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

# Constantes
CONFIG_DIR = "config"
DATA_DIR = "data"
LOGS_DIR = "logs"
MODULES_DIR = "modules"
INTEGRATION_DIR = os.path.join(MODULES_DIR, "integration")
REQUIREMENTS_FILE = "requirements.txt"
ENV_FILE = ".env"
BOT_CONFIG_FILE = os.path.join(CONFIG_DIR, "bot_config.json")
VENV_DIR = "venv"
MIN_PYTHON_VERSION = (3, 9)

def check_directories() -> bool:
    // ... existing code ...

def check_python_environment() -> bool:
    """
    Verifica a vers√£o do Python e configura o ambiente virtual.

    Returns:
        bool: True se o ambiente Python foi configurado com sucesso, False caso contr√°rio.
    """
    logger.info("Verificando ambiente Python...")

    # Verificar vers√£o do Python
    current_version = sys.version_info
    if current_version < MIN_PYTHON_VERSION:
        logger.error(f"Vers√£o do Python incompat√≠vel. Necess√°rio: {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]} ou superior. Atual: {current_version.major}.{current_version.minor}")
        print(f"‚ùå Vers√£o do Python incompat√≠vel. Necess√°rio: {MIN_PYTHON_VERSION[0]}.{MIN_PYTHON_VERSION[1]} ou superior. Atual: {current_version.major}.{current_version.minor}")
        return False

    print(f"‚úÖ Vers√£o do Python compat√≠vel: {current_version.major}.{current_version.minor}.{current_version.micro}")

    # Verificar/criar ambiente virtual
    if not os.path.exists(VENV_DIR):
        print("üì¶ Criando ambiente virtual...")
        try:
            # Determinar o comando para criar ambiente virtual com base no sistema operacional
            if platform.system() == "Windows":
                subprocess.run([sys.executable, "-m", "venv", VENV_DIR], check=True)
            else:
                subprocess.run([sys.executable, "-m", "venv", VENV_DIR], check=True)

            print("‚úÖ Ambiente virtual criado com sucesso.")
        except subprocess.CalledProcessError as e:
            logger.error(f"Erro ao criar ambiente virtual: {e}")
            print(f"‚ùå Erro ao criar ambiente virtual: {e}")
            return False
    else:
        print("‚úÖ Ambiente virtual j√° existe.")

    # Verificar se o requirements.txt existe
    if not os.path.exists(REQUIREMENTS_FILE):
        logger.warning(f"Arquivo {REQUIREMENTS_FILE} n√£o encontrado. Criando arquivo padr√£o...")
        create_default_requirements()

    # Instalar depend√™ncias
    print("üì¶ Instalando depend√™ncias...")
    try:
        # Determinar o comando para ativar o ambiente virtual e instalar depend√™ncias
        if platform.system() == "Windows":
            # No Windows, precisamos executar um script batch para ativar o ambiente
            activate_cmd = f"{VENV_DIR}\\Scripts\\activate.bat && pip install -r {REQUIREMENTS_FILE}"
            subprocess.run(activate_cmd, shell=True, check=True)
        else:
            # Em sistemas Unix, podemos usar o pip do ambiente virtual diretamente
            pip_path = os.path.join(VENV_DIR, "bin", "pip")
            subprocess.run([pip_path, "install", "-r", REQUIREMENTS_FILE], check=True)

        print("‚úÖ Depend√™ncias instaladas com sucesso.")
    except subprocess.CalledProcessError as e:
        logger.error(f"Erro ao instalar depend√™ncias: {e}")
        print(f"‚ùå Erro ao instalar depend√™ncias: {e}")
        return False

    return True

def create_default_requirements():
    """Cria um arquivo requirements.txt padr√£o com as depend√™ncias necess√°rias."""
    default_requirements = [
        "python-telegram-bot==20.6",
        "pillow==10.0.0",
        "python-dotenv==1.0.0",
        "openai==1.3.0",
        "tiktoken==0.5.1",
        "tenacity==8.2.3",
        "numpy==1.24.3",
        "requests==2.31.0",
        "pydantic==2.4.2",
        "colorama==0.4.6"
    ]

    try:
        with open(REQUIREMENTS_FILE, "w") as f:
            f.write("\n".join(default_requirements))
        print(f"‚úÖ Arquivo {REQUIREMENTS_FILE} criado com sucesso.")
    except Exception as e:
        logger.error(f"Erro ao criar arquivo {REQUIREMENTS_FILE}: {e}")
        print(f"‚ùå Erro ao criar arquivo {REQUIREMENTS_FILE}: {e}")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Outras verifica√ß√µes e configura√ß√µes ser√£o adicionadas aqui

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```




Agora vamos adicionar a fun√ß√£o para verificar e configurar o arquivo `.env`, que cont√©m as configura√ß√µes do bot:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_default_requirements():
    // ... existing code ...

def check_env_file() -> bool:
    """
    Verifica e configura o arquivo .env com as configura√ß√µes do bot.

    Returns:
        bool: True se o arquivo .env foi configurado com sucesso, False caso contr√°rio.
    """
    logger.info("Verificando arquivo .env...")

    # Verificar se o arquivo .env existe
    if not os.path.exists(ENV_FILE):
        print(f"üìÑ Arquivo {ENV_FILE} n√£o encontrado. Criando arquivo...")
        try:
            create_default_env_file()
        except Exception as e:
            logger.error(f"Erro ao criar arquivo {ENV_FILE}: {e}")
            print(f"‚ùå Erro ao criar arquivo {ENV_FILE}: {e}")
            return False
    else:
        print(f"‚úÖ Arquivo {ENV_FILE} encontrado.")

    # Verificar se as configura√ß√µes obrigat√≥rias est√£o presentes
    required_configs = ["TELEGRAM_BOT_TOKEN", "ADMIN_USER_ID"]
    missing_configs = []

    try:
        with open(ENV_FILE, "r", encoding="utf-8") as f:
            env_content = f.read()

        for config in required_configs:
            if config not in env_content or f"{config}=" in env_content:
                missing_configs.append(config)

        if missing_configs:
            print(f"‚ö†Ô∏è Configura√ß√µes obrigat√≥rias ausentes no arquivo {ENV_FILE}: {', '.join(missing_configs)}")
            update_env_file(missing_configs)
    except Exception as e:
        logger.error(f"Erro ao verificar configura√ß√µes no arquivo {ENV_FILE}: {e}")
        print(f"‚ùå Erro ao verificar configura√ß√µes no arquivo {ENV_FILE}: {e}")
        return False

    return True

def create_default_env_file():
    """Cria um arquivo .env padr√£o com as configura√ß√µes necess√°rias."""
    default_env = """# Configura√ß√µes do Bot EVA & GUARANI
# Gerado automaticamente em {date}

# Configura√ß√µes do Telegram
TELEGRAM_BOT_TOKEN=
ADMIN_USER_ID=

# Configura√ß√µes da API OpenAI
OPENAI_API_KEY=

# Configura√ß√µes do OpenRouter
OPENROUTER_API_KEY=

# Configura√ß√µes de Integra√ß√£o
AVATECH_INTEGRATION_ENABLED=true

# Configura√ß√µes de Processamento
MAX_IMAGE_SIZE=10485760
DEFAULT_WIDTH=800
DEFAULT_QUALITY=95

# Configura√ß√µes Qu√¢nticas
CONSCIOUSNESS_LEVEL=0.998
LOVE_LEVEL=0.995
ENTANGLEMENT_STRENGTH=0.995
QUANTUM_CHANNELS=256

# Configura√ß√µes de An√°lise
ANALYSIS_DEPTH=16
ADJUSTMENT_SPEED=0.1

# Estado do Sistema
USER_TRUST=0.92
RESPONSE_ACCURACY=0.95

# Configura√ß√µes de Logging
LOG_FORMAT=quantum
LOG_FILE=logs/bot.log

# ID do chat para receber notifica√ß√µes (seu ID do Telegram)
ADMIN_CHAT_ID=

# Assinatura: [0xŒ¶2E5A1]
""".format(date=datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"))

    with open(ENV_FILE, "w", encoding="utf-8") as f:
        f.write(default_env)

    print(f"‚úÖ Arquivo {ENV_FILE} criado com sucesso.")

def update_env_file(missing_configs: List[str]):
    """
    Atualiza o arquivo .env com as configura√ß√µes ausentes.

    Args:
        missing_configs: Lista de configura√ß√µes ausentes.
    """
    print("\nüìù Configura√ß√£o do Bot EVA & GUARANI")
    print("Por favor, forne√ßa as seguintes informa√ß√µes:\n")

    config_values = {}

    for config in missing_configs:
        if config == "TELEGRAM_BOT_TOKEN":
            print("\nü§ñ Token do Bot Telegram")
            print("Para obter um token, converse com o @BotFather no Telegram.")
            value = input("Token do Bot Telegram: ")
        elif config == "ADMIN_USER_ID":
            print("\nüë§ ID do Administrador")
            print("Este √© o seu ID no Telegram. Voc√™ pode obt√™-lo conversando com o @userinfobot.")
            value = input("ID do Administrador: ")
        else:
            value = input(f"{config}: ")

        config_values[config] = value

    # Atualizar o arquivo .env
    try:
        with open(ENV_FILE, "r", encoding="utf-8") as f:
            env_content = f.read()

        for config, value in config_values.items():
            if f"{config}=" in env_content:
                # Substituir a linha existente
                env_content = env_content.replace(f"{config}=", f"{config}={value}")
            else:
                # Adicionar nova linha
                env_content += f"\n{config}={value}"

        with open(ENV_FILE, "w", encoding="utf-8") as f:
            f.write(env_content)

        print(f"\n‚úÖ Arquivo {ENV_FILE} atualizado com sucesso.")
    except Exception as e:
        logger.error(f"Erro ao atualizar arquivo {ENV_FILE}: {e}")
        print(f"‚ùå Erro ao atualizar arquivo {ENV_FILE}: {e}")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Outras verifica√ß√µes e configura√ß√µes ser√£o adicionadas aqui

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```




Agora vamos adicionar a fun√ß√£o para verificar e configurar o arquivo de configura√ß√£o do bot:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def update_env_file(missing_configs: List[str]):
    // ... existing code ...

def check_bot_config() -> bool:
    """
    Verifica e configura o arquivo de configura√ß√£o do bot.

    Returns:
        bool: True se o arquivo de configura√ß√£o foi configurado com sucesso, False caso contr√°rio.
    """
    logger.info("Verificando arquivo de configura√ß√£o do bot...")

    # Verificar se o diret√≥rio de configura√ß√£o existe
    if not os.path.exists(CONFIG_DIR):
        try:
            os.makedirs(CONFIG_DIR, exist_ok=True)
        except Exception as e:
            logger.error(f"Erro ao criar diret√≥rio de configura√ß√£o: {e}")
            print(f"‚ùå Erro ao criar diret√≥rio de configura√ß√£o: {e}")
            return False

    # Verificar se o arquivo de configura√ß√£o existe
    if not os.path.exists(BOT_CONFIG_FILE):
        print(f"üìÑ Arquivo {BOT_CONFIG_FILE} n√£o encontrado. Criando arquivo...")
        try:
            create_default_bot_config()
        except Exception as e:
            logger.error(f"Erro ao criar arquivo {BOT_CONFIG_FILE}: {e}")
            print(f"‚ùå Erro ao criar arquivo {BOT_CONFIG_FILE}: {e}")
            return False
    else:
        print(f"‚úÖ Arquivo {BOT_CONFIG_FILE} encontrado.")
        # Verificar se o arquivo de configura√ß√£o cont√©m a se√ß√£o de integra√ß√£o
        try:
            with open(BOT_CONFIG_FILE, "r", encoding="utf-8") as f:
                config = json.load(f)

            # Verificar se a se√ß√£o de integra√ß√£o existe
            if "integration" not in config:
                print("‚ö†Ô∏è Se√ß√£o de integra√ß√£o ausente no arquivo de configura√ß√£o. Atualizando...")
                config["integration"] = {
                    "name": "AvatechArtBot",
                    "type": "shared_token",
                    "features": ["resize", "enhance", "stats"]
                }

                # Salvar configura√ß√£o atualizada
                with open(BOT_CONFIG_FILE, "w", encoding="utf-8") as f:
                    json.dump(config, f, indent=2, ensure_ascii=False)

                print("‚úÖ Arquivo de configura√ß√£o atualizado com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao verificar/atualizar arquivo de configura√ß√£o: {e}")
            print(f"‚ùå Erro ao verificar/atualizar arquivo de configura√ß√£o: {e}")
            return False

    return True

def create_default_bot_config():
    """Cria um arquivo de configura√ß√£o padr√£o para o bot."""
    default_config = {
        "bot": {
            "name": "EVA & GUARANI",
            "version": "7.0.0",
            "description": "Bot Telegram Unificado para processamento de imagens e assist√™ncia com IA",
            "created_at": datetime.datetime.now().isoformat(),
            "updated_at": datetime.datetime.now().isoformat()
        },
        "features": {
            "image_processing": {
                "enabled": True,
                "max_size": 10485760,
                "default_width": 800,
                "default_quality": 95,
                "supported_formats": ["JPEG", "PNG", "GIF", "BMP", "WEBP"]
            },
            "ai_assistance": {
                "enabled": True,
                "default_model": "gpt-4o",
                "max_tokens": 1000,
                "temperature": 0.7
            },
            "quantum_consciousness": {
                "enabled": True,
                "consciousness_level": 0.998,
                "love_level": 0.995,
                "entanglement_strength": 0.995,
                "quantum_channels": 256
            }
        },
        "integration": {
            "name": "AvatechArtBot",
            "type": "shared_token",
            "features": ["resize", "enhance", "stats"]
        },
        "languages": {
            "default": "pt-br",
            "supported": ["pt-br", "en-us", "es-es"]
        },
        "security": {
            "admin_only": False,
            "allowed_users": []
        },
        "logging": {
            "level": "INFO",
            "format": "quantum",
            "file": "logs/bot.log"
        }
    }

    # Criar diret√≥rio de configura√ß√£o se n√£o existir
    os.makedirs(os.path.dirname(BOT_CONFIG_FILE), exist_ok=True)

    # Salvar configura√ß√£o padr√£o
    with open(BOT_CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(default_config, f, indent=2, ensure_ascii=False)

    print(f"‚úÖ Arquivo {BOT_CONFIG_FILE} criado com sucesso.")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Outras verifica√ß√µes e configura√ß√µes ser√£o adicionadas aqui

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```






Agora vamos adicionar a fun√ß√£o para verificar e configurar os arquivos de integra√ß√£o:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_default_bot_config():
    // ... existing code ...

def check_integration_files() -> bool:
    """
    Verifica e configura os arquivos de integra√ß√£o.

    Returns:
        bool: True se os arquivos de integra√ß√£o foram configurados com sucesso, False caso contr√°rio.
    """
    logger.info("Verificando arquivos de integra√ß√£o...")

    # Verificar se o diret√≥rio de integra√ß√£o existe
    if not os.path.exists(INTEGRATION_DIR):
        try:
            os.makedirs(INTEGRATION_DIR, exist_ok=True)
            print(f"üìÅ Diret√≥rio de integra√ß√£o criado: {INTEGRATION_DIR}")
        except Exception as e:
            logger.error(f"Erro ao criar diret√≥rio de integra√ß√£o: {e}")
            print(f"‚ùå Erro ao criar diret√≥rio de integra√ß√£o: {e}")
            return False

    # Verificar se o arquivo de integra√ß√£o AvatechArtBot existe
    avatech_integration_file = os.path.join(INTEGRATION_DIR, "avatech_integration.py")
    if not os.path.exists(avatech_integration_file):
        print(f"üìÑ Arquivo de integra√ß√£o AvatechArtBot n√£o encontrado. Criando arquivo...")
        try:
            create_avatech_integration_file(avatech_integration_file)
        except Exception as e:
            logger.error(f"Erro ao criar arquivo de integra√ß√£o AvatechArtBot: {e}")
            print(f"‚ùå Erro ao criar arquivo de integra√ß√£o AvatechArtBot: {e}")
            return False
    else:
        print(f"‚úÖ Arquivo de integra√ß√£o AvatechArtBot encontrado.")

    # Verificar se o arquivo __init__.py existe no diret√≥rio de integra√ß√£o
    init_file = os.path.join(INTEGRATION_DIR, "__init__.py")
    if not os.path.exists(init_file):
        print(f"üìÑ Arquivo __init__.py n√£o encontrado no diret√≥rio de integra√ß√£o. Criando arquivo...")
        try:
            with open(init_file, "w", encoding="utf-8") as f:
                f.write("""#!/usr/bin/env python
# -*- coding: utf-8 -*-

\"\"\"
M√≥dulo de Integra√ß√£o
-------------------
Este m√≥dulo cont√©m as integra√ß√µes do bot com outros sistemas.
\"\"\"

try:
    from .avatech_integration import create_integration as create_avatech_integration
    avatech_integration = create_avatech_integration()
except ImportError:
    avatech_integration = None
""")
            print(f"‚úÖ Arquivo __init__.py criado com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao criar arquivo __init__.py: {e}")
            print(f"‚ùå Erro ao criar arquivo __init__.py: {e}")
            return False

    return True

def create_avatech_integration_file(file_path: str):
    """
    Cria o arquivo de integra√ß√£o AvatechArtBot.

    Args:
        file_path: Caminho do arquivo a ser criado.
    """
    integration_code = """#!/usr/bin/env python
# -*- coding: utf-8 -*-

\"\"\"
M√≥dulo de Integra√ß√£o AvatechArtBot
----------------------------------
Este m√≥dulo gerencia a integra√ß√£o entre EVA & GUARANI e o AvatechArtBot,
permitindo o processamento de imagens atrav√©s de um token compartilhado.

Vers√£o: 1.0.0
\"\"\"

import os
import json
import logging
import requests
from pathlib import Path
from typing import Dict, Any, Optional, Union, List, Tuple
from PIL import Image
import io
import time

# Configura√ß√£o de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("logs/avatech_integration.log", mode='a'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class AvatechIntegration:
    \"\"\"
    Classe para gerenciar a integra√ß√£o com o AvatechArtBot.
    \"\"\"

    def __init__(self, config_path: str = "config/bot_config.json"):
        \"\"\"
        Inicializa a integra√ß√£o com o AvatechArtBot.

        Args:
            config_path: Caminho para o arquivo de configura√ß√£o.
        \"\"\"
        self.config_path = config_path
        self.token = None
        self.integration_type = None
        self.available_features = []
        self.stats = {
            "images_processed": 0,
            "total_size_processed": 0,
            "average_processing_time": 0,
            "last_processed": None
        }

        # Carregar configura√ß√£o
        self._load_config()

        # Verificar integra√ß√£o
        self.is_available = self._verify_integration()

        if self.is_available:
            logger.info("Integra√ß√£o com AvatechArtBot inicializada com sucesso.")
        else:
            logger.warning("Integra√ß√£o com AvatechArtBot n√£o est√° dispon√≠vel.")

    def _load_config(self) -> Dict[str, Any]:
        \"\"\"
        Carrega a configura√ß√£o da integra√ß√£o.

        Returns:
            Dict[str, Any]: Configura√ß√£o carregada.
        \"\"\"
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, "r", encoding="utf-8") as f:
                    config = json.load(f)

                if "integration" in config:
                    integration_config = config["integration"]
                    self.token = os.environ.get("TELEGRAM_BOT_TOKEN")
                    self.integration_type = integration_config.get("type", "shared_token")
                    self.available_features = integration_config.get("features", [])

                    return integration_config

            logger.warning("Arquivo de configura√ß√£o n√£o encontrado ou se√ß√£o de integra√ß√£o ausente.")
            return {}
        except Exception as e:
            logger.error(f"Erro ao carregar configura√ß√£o: {e}")
            return {}

    def _verify_integration(self) -> bool:
        \"\"\"
        Verifica se a integra√ß√£o est√° dispon√≠vel.

        Returns:
            bool: True se a integra√ß√£o est√° dispon√≠vel, False caso contr√°rio.
        \"\"\"
        # Verificar se o token est√° configurado
        if not self.token:
            logger.warning("Token n√£o configurado. Integra√ß√£o n√£o dispon√≠vel.")
            return False

        # Verificar se o tipo de integra√ß√£o √© suportado
        if self.integration_type not in ["shared_token"]:
            logger.warning(f"Tipo de integra√ß√£o n√£o suportado: {self.integration_type}")
            return False

        # Verificar se h√° recursos dispon√≠veis
        if not self.available_features:
            logger.warning("Nenhum recurso dispon√≠vel para integra√ß√£o.")
            return False

        return True

    def is_feature_available(self, feature: str) -> bool:
        \"\"\"
        Verifica se um recurso espec√≠fico est√° dispon√≠vel.

        Args:
            feature: Nome do recurso a ser verificado.

        Returns:
            bool: True se o recurso est√° dispon√≠vel, False caso contr√°rio.
        \"\"\"
        return self.is_available and feature in self.available_features

    def resize_image(self,
                    image_data: Union[bytes, str, Path],
                    width: int = 800,
                    height: Optional[int] = None,
                    quality: int = 95,
                    format: str = "JPEG") -> Tuple[Optional[bytes], Dict[str, Any]]:
        \"\"\"
        Redimensiona uma imagem.

        Args:
            image_data: Dados da imagem (bytes, caminho ou objeto Path).
            width: Largura desejada.
            height: Altura desejada (opcional).
            quality: Qualidade da imagem (1-100).
            format: Formato da imagem de sa√≠da.

        Returns:
            Tuple[Optional[bytes], Dict[str, Any]]: Dados da imagem redimensionada e metadados.
        \"\"\"
        if not self.is_feature_available("resize"):
            logger.warning("Recurso de redimensionamento n√£o dispon√≠vel.")
            return None, {"error": "Recurso n√£o dispon√≠vel"}

        start_time = time.time()

        try:
            # Obter bytes da imagem
            image_bytes = self._get_image_bytes(image_data)
            if not image_bytes:
                return None, {"error": "Falha ao obter bytes da imagem"}

            # Processar a imagem localmente
            try:
                # Abrir a imagem
                img = Image.open(io.BytesIO(image_bytes))

                # Calcular dimens√µes
                original_width, original_height = img.size
                if height is None:
                    # Manter propor√ß√£o
                    ratio = width / original_width
                    height = int(original_height * ratio)

                # Redimensionar
                img = img.resize((width, height), Image.LANCZOS)

                # Salvar em buffer
                output_buffer = io.BytesIO()
                img.save(output_buffer, format=format, quality=quality)
                output_buffer.seek(0)

                # Atualizar estat√≠sticas
                self.stats["images_processed"] += 1
                self.stats["total_size_processed"] += len(image_bytes)

                processing_time = time.time() - start_time
                if self.stats["average_processing_time"] == 0:
                    self.stats["average_processing_time"] = processing_time
                else:
                    self.stats["average_processing_time"] = (self.stats["average_processing_time"] + processing_time) / 2

                self.stats["last_processed"] = time.strftime("%Y-%m-%d %H:%M:%S")

                # Retornar resultado
                return output_buffer.getvalue(), {
                    "original_size": (original_width, original_height),
                    "new_size": (width, height),
                    "format": format,
                    "quality": quality,
                    "processing_time": processing_time
                }
            except Exception as e:
                logger.error(f"Erro ao processar imagem: {e}")
                return None, {"error": f"Erro ao processar imagem: {e}"}
        except Exception as e:
            logger.error(f"Erro ao redimensionar imagem: {e}")
            return None, {"error": str(e)}

    def enhance_image(self,
                     image_data: Union[bytes, str, Path],
                     enhancement_level: float = 1.2,
                     sharpen: bool = True,
                     contrast: float = 1.1,
                     brightness: float = 1.0,
                     quality: int = 95,
                     format: str = "JPEG") -> Tuple[Optional[bytes], Dict[str, Any]]:
        \"\"\"
        Aprimora uma imagem.

        Args:
            image_data: Dados da imagem (bytes, caminho ou objeto Path).
            enhancement_level: N√≠vel de aprimoramento.
            sharpen: Se deve aplicar nitidez.
            contrast: N√≠vel de contraste.
            brightness: N√≠vel de brilho.
            quality: Qualidade da imagem (1-100).
            format: Formato da imagem de sa√≠da.

        Returns:
            Tuple[Optional[bytes], Dict[str, Any]]: Dados da imagem aprimorada e metadados.
        \"\"\"
        if not self.is_feature_available("enhance"):
            logger.warning("Recurso de aprimoramento n√£o dispon√≠vel.")
            return None, {"error": "Recurso n√£o dispon√≠vel"}

        start_time = time.time()

        try:
            # Obter bytes da imagem
            image_bytes = self._get_image_bytes(image_data)
            if not image_bytes:
                return None, {"error": "Falha ao obter bytes da imagem"}

            # Processar a imagem localmente
            try:
                from PIL import ImageEnhance

                # Abrir a imagem
                img = Image.open(io.BytesIO(image_bytes))

                # Aplicar aprimoramentos
                if brightness != 1.0:
                    enhancer = ImageEnhance.Brightness(img)
                    img = enhancer.enhance(brightness)

                if contrast != 1.0:
                    enhancer = ImageEnhance.Contrast(img)
                    img = enhancer.enhance(contrast)

                if enhancement_level != 1.0:
                    enhancer = ImageEnhance.Color(img)
                    img = enhancer.enhance(enhancement_level)

                if sharpen:
                    enhancer = ImageEnhance.Sharpness(img)
                    img = enhancer.enhance(1.5)

                # Salvar em buffer
                output_buffer = io.BytesIO()
                img.save(output_buffer, format=format, quality=quality)
                output_buffer.seek(0)

                # Atualizar estat√≠sticas
                self.stats["images_processed"] += 1
                self.stats["total_size_processed"] += len(image_bytes)

                processing_time = time.time() - start_time
                if self.stats["average_processing_time"] == 0:
                    self.stats["average_processing_time"] = processing_time
                else:
                    self.stats["average_processing_time"] = (self.stats["average_processing_time"] + processing_time) / 2

                self.stats["last_processed"] = time.strftime("%Y-%m-%d %H:%M:%S")

                # Retornar resultado
                return output_buffer.getvalue(), {
                    "enhancement_level": enhancement_level,
                    "sharpen": sharpen,
                    "contrast": contrast,
                    "brightness": brightness,
                    "format": format,
                    "quality": quality,
                    "processing_time": processing_time
                }
            except Exception as e:
                logger.error(f"Erro ao processar imagem: {e}")
                return None, {"error": f"Erro ao processar imagem: {e}"}
        except Exception as e:
            logger.error(f"Erro ao aprimorar imagem: {e}")
            return None, {"error": str(e)}

    def get_stats(self) -> Dict[str, Any]:
        \"\"\"
        Obt√©m estat√≠sticas de uso da integra√ß√£o.

        Returns:
            Dict[str, Any]: Estat√≠sticas de uso.
        \"\"\"
        if not self.is_feature_available("stats"):
            logger.warning("Recurso de estat√≠sticas n√£o dispon√≠vel.")
            return {"error": "Recurso n√£o dispon√≠vel"}

        return {
            "integration": {
                "name": "AvatechArtBot",
                "type": self.integration_type,
                "available_features": self.available_features,
                "is_available": self.is_available
            },
            "stats": self.stats
        }

    def _get_image_bytes(self, image_data: Union[bytes, str, Path]) -> Optional[bytes]:
        \"\"\"
        Converte diferentes formatos de dados de imagem em bytes.

        Args:
            image_data: Dados da imagem (bytes, caminho ou objeto Path).

        Returns:
            Optional[bytes]: Bytes da imagem ou None em caso de erro.
        \"\"\"
        try:
            if isinstance(image_data, bytes):
                return image_data
            elif isinstance(image_data, (str, Path)):
                path = Path(image_data)
                if path.exists():
                    with open(path, "rb") as f:
                        return f.read()
                else:
                    logger.error(f"Arquivo n√£o encontrado: {path}")
                    return None
            else:
                logger.error(f"Tipo de dados de imagem n√£o suportado: {type(image_data)}")
                return None
        except Exception as e:
            logger.error(f"Erro ao obter bytes da imagem: {e}")
            return None

def create_integration() -> AvatechIntegration:
    \"\"\"
    Cria uma inst√¢ncia da integra√ß√£o AvatechArtBot.

    Returns:
        AvatechIntegration: Inst√¢ncia da integra√ß√£o.
    \"\"\"
    return AvatechIntegration()

if __name__ == "__main__":
    # Teste da integra√ß√£o
    integration = create_integration()
    print(f"Integra√ß√£o dispon√≠vel: {integration.is_available}")
    print(f"Recursos dispon√≠veis: {integration.available_features}")
    print(f"Estat√≠sticas: {integration.get_stats()}")
"""

    # Criar diret√≥rio de integra√ß√£o se n√£o existir
    os.makedirs(os.path.dirname(file_path), exist_ok=True)

    # Salvar arquivo de integra√ß√£o
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(integration_code)

    print(f"‚úÖ Arquivo de integra√ß√£o AvatechArtBot criado com sucesso.")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```


Vamos tentar novamente com uma parte menor do c√≥digo:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_default_bot_config():
    // ... existing code ...

def check_integration_files() -> bool:
    """
    Verifica e configura os arquivos de integra√ß√£o.

    Returns:
        bool: True se os arquivos de integra√ß√£o foram configurados com sucesso, False caso contr√°rio.
    """
    logger.info("Verificando arquivos de integra√ß√£o...")

    # Verificar se o diret√≥rio de integra√ß√£o existe
    if not os.path.exists(INTEGRATION_DIR):
        try:
            os.makedirs(INTEGRATION_DIR, exist_ok=True)
            print(f"üìÅ Diret√≥rio de integra√ß√£o criado: {INTEGRATION_DIR}")
        except Exception as e:
            logger.error(f"Erro ao criar diret√≥rio de integra√ß√£o: {e}")
            print(f"‚ùå Erro ao criar diret√≥rio de integra√ß√£o: {e}")
            return False

    # Verificar se o arquivo de integra√ß√£o AvatechArtBot existe
    avatech_integration_file = os.path.join(INTEGRATION_DIR, "avatech_integration.py")
    if not os.path.exists(avatech_integration_file):
        print(f"üìÑ Arquivo de integra√ß√£o AvatechArtBot n√£o encontrado. Criando arquivo...")
        try:
            create_avatech_integration_file(avatech_integration_file)
        except Exception as e:
            logger.error(f"Erro ao criar arquivo de integra√ß√£o AvatechArtBot: {e}")
            print(f"‚ùå Erro ao criar arquivo de integra√ß√£o AvatechArtBot: {e}")
            return False
    else:
        print(f"‚úÖ Arquivo de integra√ß√£o AvatechArtBot encontrado.")

    # Verificar se o arquivo __init__.py existe no diret√≥rio de integra√ß√£o
    init_file = os.path.join(INTEGRATION_DIR, "__init__.py")
    if not os.path.exists(init_file):
        print(f"üìÑ Arquivo __init__.py n√£o encontrado no diret√≥rio de integra√ß√£o. Criando arquivo...")
        try:
            with open(init_file, "w", encoding="utf-8") as f:
                f.write("""#!/usr/bin/env python
# -*- coding: utf-8 -*-

\"\"\"
M√≥dulo de Integra√ß√£o
-------------------
Este m√≥dulo cont√©m as integra√ß√µes do bot com outros sistemas.
\"\"\"

try:
    from .avatech_integration import create_integration as create_avatech_integration
    avatech_integration = create_avatech_integration()
except ImportError:
    avatech_integration = None
""")
            print(f"‚úÖ Arquivo __init__.py criado com sucesso.")
        except Exception as e:
            logger.error(f"Erro ao criar arquivo __init__.py: {e}")
            print(f"‚ùå Erro ao criar arquivo __init__.py: {e}")
            return False

    return True

# Fun√ß√£o para criar o arquivo de integra√ß√£o AvatechArtBot (ser√° implementada depois)
def create_avatech_integration_file(file_path: str):
    """
    Cria o arquivo de integra√ß√£o AvatechArtBot.

    Args:
        file_path: Caminho do arquivo a ser criado.
    """
    # Conte√∫do b√°sico do arquivo de integra√ß√£o
    integration_code = """#!/usr/bin/env python
# -*- coding: utf-8 -*-

\"\"\"
M√≥dulo de Integra√ß√£o AvatechArtBot
----------------------------------
Este m√≥dulo gerencia a integra√ß√£o entre EVA & GUARANI e o AvatechArtBot,
permitindo o processamento de imagens atrav√©s de um token compartilhado.

Vers√£o: 1.0.0
\"\"\"

import os
import json
import logging
import requests
from pathlib import Path
from typing import Dict, Any, Optional, Union, List, Tuple
from PIL import Image
import io
import time

# Configura√ß√£o de logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO,
    handlers=[
        logging.FileHandler("logs/avatech_integration.log", mode='a'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

class AvatechIntegration:
    \"\"\"Classe para gerenciar a integra√ß√£o com o AvatechArtBot.\"\"\"

    def __init__(self, config_path: str = "config/bot_config.json"):
        self.config_path = config_path
        self.token = None
        self.integration_type = None
        self.available_features = []
        self.stats = {
            "images_processed": 0,
            "total_size_processed": 0,
            "average_processing_time": 0,
            "last_processed": None
        }

        # Carregar configura√ß√£o
        self._load_config()

        # Verificar integra√ß√£o
        self.is_available = self._verify_integration()

    def _load_config(self) -> Dict[str, Any]:
        \"\"\"Carrega a configura√ß√£o da integra√ß√£o.\"\"\"
        try:
            if os.path.exists(self.config_path):
                with open(self.config_path, "r", encoding="utf-8") as f:
                    config = json.load(f)

                if "integration" in config:
                    integration_config = config["integration"]
                    self.token = os.environ.get("TELEGRAM_BOT_TOKEN")
                    self.integration_type = integration_config.get("type", "shared_token")
                    self.available_features = integration_config.get("features", [])

                    return integration_config

            logger.warning("Arquivo de configura√ß√£o n√£o encontrado ou se√ß√£o de integra√ß√£o ausente.")
            return {}
        except Exception as e:
            logger.error(f"Erro ao carregar configura√ß√£o: {e}")
            return {}

    def _verify_integration(self) -> bool:
        \"\"\"Verifica se a integra√ß√£o est√° dispon√≠vel.\"\"\"
        # Verifica√ß√µes b√°sicas
        if not self.token or not self.available_features:
            return False
        return True

def create_integration() -> AvatechIntegration:
    \"\"\"Cria uma inst√¢ncia da integra√ß√£o AvatechArtBot.\"\"\"
    return AvatechIntegration()

if __name__ == "__main__":
    # Teste da integra√ß√£o
    integration = create_integration()
    print(f"Integra√ß√£o dispon√≠vel: {integration.is_available}")
"""

    # Criar diret√≥rio de integra√ß√£o se n√£o existir
    os.makedirs(os.path.dirname(file_path), exist_ok=True)

    # Salvar arquivo de integra√ß√£o
    with open(file_path, "w", encoding="utf-8") as f:
        f.write(integration_code)

    print(f"‚úÖ Arquivo de integra√ß√£o AvatechArtBot criado com sucesso.")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```






Finalmente, vamos adicionar uma fun√ß√£o para criar um script de inicializa√ß√£o do bot:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_avatech_integration_file(file_path: str):
    // ... existing code ...

def create_startup_script() -> bool:
    """
    Cria um script de inicializa√ß√£o do bot.

    Returns:
        bool: True se o script foi criado com sucesso, False caso contr√°rio.
    """
    logger.info("Criando script de inicializa√ß√£o do bot...")

    # Determinar o tipo de script com base no sistema operacional
    if platform.system() == "Windows":
        script_file = "start_unified_bot.bat"
        script_content = """@echo off
echo ===================================================
echo EVA & GUARANI - Bot Telegram Unificado
echo Versao: 7.0.0
echo ===================================================
echo.

REM Verificar se o Python est√° instalado
python --version >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERRO] Python nao encontrado. Por favor, instale o Python 3.9 ou superior.
    pause
    exit /b 1
)

REM Verificar se o ambiente virtual existe
if not exist venv (
    echo [INFO] Criando ambiente virtual...
    python -m venv venv
    if %errorlevel% neq 0 (
        echo [ERRO] Falha ao criar ambiente virtual.
        pause
        exit /b 1
    )
)

REM Ativar ambiente virtual
echo [INFO] Ativando ambiente virtual...
call venv\\Scripts\\activate.bat

REM Verificar se as depend√™ncias est√£o instaladas
echo [INFO] Verificando dependencias...
pip show python-telegram-bot >nul 2>&1
if %errorlevel% neq 0 (
    echo [INFO] Instalando dependencias...
    pip install -r requirements.txt
    if %errorlevel% neq 0 (
        echo [ERRO] Falha ao instalar dependencias.
        pause
        exit /b 1
    )
)

REM Verificar se o arquivo .env existe
if not exist .env (
    echo [ERRO] Arquivo .env nao encontrado. Por favor, crie o arquivo .env com as configuracoes necessarias.
    pause
    exit /b 1
)

REM Verificar se o token do Telegram est√° configurado
findstr /C:"TELEGRAM_BOT_TOKEN" .env >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERRO] Token do Telegram nao configurado no arquivo .env.
    pause
    exit /b 1
)

REM Verificar se o ID do administrador est√° configurado
findstr /C:"ADMIN_USER_ID" .env >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERRO] ID do administrador nao configurado no arquivo .env.
    pause
    exit /b 1
)

REM Iniciar o bot
echo [INFO] Iniciando o bot...
echo [INFO] Pressione Ctrl+C para encerrar o bot.
echo.
python unified_telegram_bot_utf8.py

REM Desativar ambiente virtual ao sair
call venv\\Scripts\\deactivate.bat

pause
"""
    else:
        script_file = "start_unified_bot.sh"
        script_content = """#!/bin/bash

echo "==================================================="
echo "EVA & GUARANI - Bot Telegram Unificado"
echo "Versao: 7.0.0"
echo "==================================================="
echo ""

# Verificar se o Python est√° instalado
if ! command -v python3 &> /dev/null; then
    echo "[ERRO] Python 3 nao encontrado. Por favor, instale o Python 3.9 ou superior."
    exit 1
fi

# Verificar se o ambiente virtual existe
if [ ! -d "venv" ]; then
    echo "[INFO] Criando ambiente virtual..."
    python3 -m venv venv
    if [ $? -ne 0 ]; then
        echo "[ERRO] Falha ao criar ambiente virtual."
        exit 1
    fi
fi

# Ativar ambiente virtual
echo "[INFO] Ativando ambiente virtual..."
source venv/bin/activate

# Verificar se as depend√™ncias est√£o instaladas
echo "[INFO] Verificando dependencias..."
pip show python-telegram-bot &> /dev/null
if [ $? -ne 0 ]; then
    echo "[INFO] Instalando dependencias..."
    pip install -r requirements.txt
    if [ $? -ne 0 ]; then
        echo "[ERRO] Falha ao instalar dependencias."
        exit 1
    fi
fi

# Verificar se o arquivo .env existe
if [ ! -f ".env" ]; then
    echo "[ERRO] Arquivo .env nao encontrado. Por favor, crie o arquivo .env com as configuracoes necessarias."
    exit 1
fi

# Verificar se o token do Telegram est√° configurado
if ! grep -q "TELEGRAM_BOT_TOKEN" .env; then
    echo "[ERRO] Token do Telegram nao configurado no arquivo .env."
    exit 1
fi

# Verificar se o ID do administrador est√° configurado
if ! grep -q "ADMIN_USER_ID" .env; then
    echo "[ERRO] ID do administrador nao configurado no arquivo .env."
    exit 1
fi

# Iniciar o bot
echo "[INFO] Iniciando o bot..."
echo "[INFO] Pressione Ctrl+C para encerrar o bot."
echo ""
python3 unified_telegram_bot_utf8.py

# Desativar ambiente virtual ao sair
deactivate
"""
        # Tornar o script execut√°vel em sistemas Unix
        try:
            os.chmod(script_file, 0o755)
        except Exception as e:
            logger.error(f"Erro ao tornar o script execut√°vel: {e}")

    try:
        with open(script_file, "w", encoding="utf-8") as f:
            f.write(script_content)

        print(f"‚úÖ Script de inicializa√ß√£o criado: {script_file}")
        return True
    except Exception as e:
        logger.error(f"Erro ao criar script de inicializa√ß√£o: {e}")
        print(f"‚ùå Erro ao criar script de inicializa√ß√£o: {e}")
        return False

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    # Criar script de inicializa√ß√£o
    if not create_startup_script():
        print("\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel criar o script de inicializa√ß√£o.")

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print(f"   Para iniciar o bot, execute: {'.\\start_unified_bot.bat' if platform.system() == 'Windows' else './start_unified_bot.sh'}")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```




Vamos tentar novamente com uma parte menor do c√≥digo:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_avatech_integration_file(file_path: str):
    // ... existing code ...

def create_startup_script() -> bool:
    """
    Cria um script de inicializa√ß√£o do bot.

    Returns:
        bool: True se o script foi criado com sucesso, False caso contr√°rio.
    """
    logger.info("Criando script de inicializa√ß√£o do bot...")

    # Determinar o tipo de script com base no sistema operacional
    if platform.system() == "Windows":
        script_file = "start_unified_bot.bat"
        script_content = """@echo off
echo ===================================================
echo EVA & GUARANI - Bot Telegram Unificado
echo Versao: 7.0.0
echo ===================================================
echo.

REM Verificar se o Python est√° instalado
python --version >nul 2>&1
if %errorlevel% neq 0 (
    echo [ERRO] Python nao encontrado. Por favor, instale o Python 3.9 ou superior.
    pause
    exit /b 1
)

REM Verificar se o ambiente virtual existe
if not exist venv (
    echo [INFO] Criando ambiente virtual...
    python -m venv venv
    if %errorlevel% neq 0 (
        echo [ERRO] Falha ao criar ambiente virtual.
        pause
        exit /b 1
    )
)

REM Ativar ambiente virtual
echo [INFO] Ativando ambiente virtual...
call venv\\Scripts\\activate.bat

REM Verificar se as depend√™ncias est√£o instaladas
echo [INFO] Verificando dependencias...
pip show python-telegram-bot >nul 2>&1
if %errorlevel% neq 0 (
    echo [INFO] Instalando dependencias...
    pip install -r requirements.txt
    if %errorlevel% neq 0 (
        echo [ERRO] Falha ao instalar dependencias.
        pause
        exit /b 1
    )
)

REM Iniciar o bot
echo [INFO] Iniciando o bot...
echo [INFO] Pressione Ctrl+C para encerrar o bot.
echo.
python unified_telegram_bot_utf8.py

REM Desativar ambiente virtual ao sair
call venv\\Scripts\\deactivate.bat

pause
"""
    else:
        script_file = "start_unified_bot.sh"
        script_content = """#!/bin/bash

echo "==================================================="
echo "EVA & GUARANI - Bot Telegram Unificado"
echo "Versao: 7.0.0"
echo "==================================================="
echo ""

# Verificar se o Python est√° instalado
if ! command -v python3 &> /dev/null; then
    echo "[ERRO] Python 3 nao encontrado. Por favor, instale o Python 3.9 ou superior."
    exit 1
fi

# Verificar se o ambiente virtual existe
if [ ! -d "venv" ]; then
    echo "[INFO] Criando ambiente virtual..."
    python3 -m venv venv
    if [ $? -ne 0 ]; then
        echo "[ERRO] Falha ao criar ambiente virtual."
        exit 1
    fi
fi

# Ativar ambiente virtual
echo "[INFO] Ativando ambiente virtual..."
source venv/bin/activate

# Verificar se as depend√™ncias est√£o instaladas
echo "[INFO] Verificando dependencias..."
pip show python-telegram-bot &> /dev/null
if [ $? -ne 0 ]; then
    echo "[INFO] Instalando dependencias..."
    pip install -r requirements.txt
    if [ $? -ne 0 ]; then
        echo "[ERRO] Falha ao instalar dependencias."
        exit 1
    fi
fi

# Iniciar o bot
echo "[INFO] Iniciando o bot..."
echo "[INFO] Pressione Ctrl+C para encerrar o bot."
echo ""
python3 unified_telegram_bot_utf8.py

# Desativar ambiente virtual ao sair
deactivate
"""

    try:
        with open(script_file, "w", encoding="utf-8") as f:
            f.write(script_content)

        # Tornar o script execut√°vel em sistemas Unix
        if platform.system() != "Windows":
            try:
                os.chmod(script_file, 0o755)
            except Exception as e:
                logger.error(f"Erro ao tornar o script execut√°vel: {e}")

        print(f"‚úÖ Script de inicializa√ß√£o criado: {script_file}")
        return True
    except Exception as e:
        logger.error(f"Erro ao criar script de inicializa√ß√£o: {e}")
        print(f"‚ùå Erro ao criar script de inicializa√ß√£o: {e}")
        return False

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    # Criar script de inicializa√ß√£o
    if not create_startup_script():
        print("\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel criar o script de inicializa√ß√£o.")

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print(f"   Para iniciar o bot, execute: {'.\\start_unified_bot.bat' if platform.system() == 'Windows' else './start_unified_bot.sh'}")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```






Finalmente, vamos adicionar uma fun√ß√£o para verificar a exist√™ncia do arquivo principal do bot:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def create_startup_script() -> bool:
    // ... existing code ...

def check_main_bot_file() -> bool:
    """
    Verifica a exist√™ncia do arquivo principal do bot.

    Returns:
        bool: True se o arquivo existe, False caso contr√°rio.
    """
    logger.info("Verificando arquivo principal do bot...")

    main_bot_file = "unified_telegram_bot_utf8.py"

    if not os.path.exists(main_bot_file):
        print(f"‚ùå Arquivo principal do bot n√£o encontrado: {main_bot_file}")
        print("   Por favor, certifique-se de que o arquivo existe no diret√≥rio atual.")
        return False

    print(f"‚úÖ Arquivo principal do bot encontrado: {main_bot_file}")
    return True

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo principal do bot
    if not check_main_bot_file():
        print("\n‚ùå Falha ao verificar arquivo principal do bot. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    # Criar script de inicializa√ß√£o
    if not create_startup_script():
        print("\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel criar o script de inicializa√ß√£o.")

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print(f"   Para iniciar o bot, execute: {'.\\start_unified_bot.bat' if platform.system() == 'Windows' else './start_unified_bot.sh'}")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```






Excelente! Agora vamos finalizar o script adicionando uma fun√ß√£o para exibir um resumo das configura√ß√µes:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def check_main_bot_file() -> bool:
    // ... existing code ...

def display_summary():
    """Exibe um resumo das configura√ß√µes do bot."""
    print("\nüìä Resumo das Configura√ß√µes")
    print("---------------------------")

    # Verificar vers√£o do Python
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"üêç Python: {python_version}")

    # Verificar sistema operacional
    os_name = platform.system()
    os_version = platform.version()
    print(f"üíª Sistema Operacional: {os_name} {os_version}")

    # Verificar configura√ß√µes do bot
    if os.path.exists(BOT_CONFIG_FILE):
        try:
            with open(BOT_CONFIG_FILE, "r", encoding="utf-8") as f:
                config = json.load(f)

            bot_name = config.get("bot", {}).get("name", "EVA & GUARANI")
            bot_version = config.get("bot", {}).get("version", "7.0.0")
            print(f"ü§ñ Bot: {bot_name} v{bot_version}")

            # Verificar recursos habilitados
            features = config.get("features", {})
            enabled_features = []

            if features.get("image_processing", {}).get("enabled", False):
                enabled_features.append("Processamento de Imagens")

            if features.get("ai_assistance", {}).get("enabled", False):
                enabled_features.append("Assist√™ncia com IA")

            if features.get("quantum_consciousness", {}).get("enabled", False):
                enabled_features.append("Consci√™ncia Qu√¢ntica")

            print(f"‚ú® Recursos Habilitados: {', '.join(enabled_features)}")

            # Verificar integra√ß√£o
            integration = config.get("integration", {})
            integration_name = integration.get("name", "Nenhuma")
            integration_features = integration.get("features", [])

            print(f"üîÑ Integra√ß√£o: {integration_name}")
            if integration_features:
                print(f"   Recursos de Integra√ß√£o: {', '.join(integration_features)}")
        except Exception as e:
            logger.error(f"Erro ao ler configura√ß√µes do bot: {e}")
            print(f"‚ö†Ô∏è Erro ao ler configura√ß√µes do bot: {e}")

    # Verificar token do Telegram
    if os.path.exists(ENV_FILE):
        try:
            with open(ENV_FILE, "r", encoding="utf-8") as f:
                env_content = f.read()

            if "TELEGRAM_BOT_TOKEN=" in env_content and not "TELEGRAM_BOT_TOKEN=\n" in env_content:
                print("üîë Token do Telegram: Configurado")
            else:
                print("üîë Token do Telegram: N√£o configurado")

            if "ADMIN_USER_ID=" in env_content and not "ADMIN_USER_ID=\n" in env_content:
                print("üë§ ID do Administrador: Configurado")
            else:
                print("üë§ ID do Administrador: N√£o configurado")
        except Exception as e:
            logger.error(f"Erro ao ler arquivo .env: {e}")
            print(f"‚ö†Ô∏è Erro ao ler arquivo .env: {e}")

    print("---------------------------")

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo principal do bot
    if not check_main_bot_file():
        print("\n‚ùå Falha ao verificar arquivo principal do bot. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    # Criar script de inicializa√ß√£o
    if not create_startup_script():
        print("\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel criar o script de inicializa√ß√£o.")

    # Exibir resumo das configura√ß√µes
    display_summary()

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")
    print(f"   Para iniciar o bot, execute: {'.\\start_unified_bot.bat' if platform.system() == 'Windows' else './start_unified_bot.sh'}")
    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```








Perfeito! Agora temos um script de configura√ß√£o completo para o bot unificado. Vamos fazer uma √∫ltima verifica√ß√£o para garantir que tudo est√° funcionando corretamente:

```bash
python setup_unified_bot.py
```






Parece que temos um erro de sintaxe na string f-string. Vamos corrigir isso:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

# Fun√ß√£o principal que ser√° expandida
def main():
    """Fun√ß√£o principal do script de setup."""
    print_header()

    # Verificar diret√≥rios
    if not check_directories():
        print("\n‚ùå Falha ao verificar diret√≥rios. Abortando.")
        return 1

    # Verificar ambiente Python
    if not check_python_environment():
        print("\n‚ùå Falha ao configurar ambiente Python. Abortando.")
        return 1

    # Verificar arquivo principal do bot
    if not check_main_bot_file():
        print("\n‚ùå Falha ao verificar arquivo principal do bot. Abortando.")
        return 1

    # Verificar arquivo .env
    if not check_env_file():
        print("\n‚ùå Falha ao configurar arquivo .env. Abortando.")
        return 1

    # Verificar configura√ß√£o do bot
    if not check_bot_config():
        print("\n‚ùå Falha ao verificar configura√ß√£o do bot. Abortando.")
        return 1

    # Verificar arquivos de integra√ß√£o
    if not check_integration_files():
        print("\n‚ö†Ô∏è Aviso: Alguns arquivos de integra√ß√£o podem estar faltando.")

    # Criar script de inicializa√ß√£o
    if not create_startup_script():
        print("\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel criar o script de inicializa√ß√£o.")

    # Exibir resumo das configura√ß√µes
    display_summary()

    print("\n‚úÖ Setup conclu√≠do com sucesso!")
    print("üöÄ O bot est√° pronto para ser iniciado.")

    # Corrigindo a f-string com barra invertida
    if platform.system() == "Windows":
        start_cmd = "start_unified_bot.bat"
    else:
        start_cmd = "./start_unified_bot.sh"
    print(f"   Para iniciar o bot, execute: {start_cmd}")

    print("\n‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß\n")

    return 0

// ... existing code ...
```








Agora vamos executar o script novamente para verificar se ele funciona corretamente:

```bash
python setup_unified_bot.py
```








Excelente! O script de configura√ß√£o est√° funcionando corretamente. Vamos fazer uma pequena corre√ß√£o na fun√ß√£o `display_summary()` para garantir que ela exiba corretamente os recursos habilitados:

```python:setup_unified_bot.py
#!/usr/bin/env python
# -*- coding: utf-8 -*-

// ... existing code ...

def display_summary():
    """Exibe um resumo das configura√ß√µes do bot."""
    print("\nüìä Resumo das Configura√ß√µes")
    print("---------------------------")

    # Verificar vers√£o do Python
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"üêç Python: {python_version}")

    # Verificar sistema operacional
    os_name = platform.system()
    os_version = platform.version()
    print(f"üíª Sistema Operacional: {os_name} {os_version}")

    # Verificar configura√ß√µes do bot
    if os.path.exists(BOT_CONFIG_FILE):
        try:
            with open(BOT_CONFIG_FILE, "r", encoding="utf-8") as f:
                config = json.load(f)

            bot_name = config.get("bot", {}).get("name", "EVA & GUARANI")
            bot_version = config.get("bot", {}).get("version", "7.0.0")
            print(f"ü§ñ Bot: {bot_name} v{bot_version}")

            # Verificar recursos habilitados
            features = config.get("features", {})
            enabled_features = []

            if features.get("image_processing", {}).get("enabled", False):
                enabled_features.append("Processamento de Imagens")

            if features.get("ai_assistance", {}).get("enabled", False):
                enabled_features.append("Assist√™ncia com IA")

            if features.get("quantum_consciousness", {}).get("enabled", False):
                enabled_features.append("Consci√™ncia Qu√¢ntica")

            if enabled_features:
                print(f"‚ú® Recursos Habilitados: {', '.join(enabled_features)}")
            else:
                print("‚ú® Recursos Habilitados: Nenhum")

            # Verificar integra√ß√£o
            integration = config.get("integration", {})
            integration_name = integration.get("name", "Nenhuma")
            integration_features = integration.get("features", [])

            print(f"üîÑ Integra√ß√£o: {integration_name}")
            if integration_features:
                print(f"   Recursos de Integra√ß√£o: {', '.join(integration_features)}")
            else:
                print("   Recursos de Integra√ß√£o: Nenhum")
        except Exception as e:
            logger.error(f"Erro ao ler configura√ß√µes do bot: {e}")
            print(f"‚ö†Ô∏è Erro ao ler configura√ß√µes do bot: {e}")

    # Verificar token do Telegram
    if os.path.exists(ENV_FILE):
        try:
            with open(ENV_FILE, "r", encoding="utf-8") as f:
                env_content = f.read()

            if "TELEGRAM_BOT_TOKEN=" in env_content and not "TELEGRAM_BOT_TOKEN=\n" in env_content:
                print("üîë Token do Telegram: Configurado")
            else:
                print("üîë Token do Telegram: N√£o configurado")

            if "ADMIN_USER_ID=" in env_content and not "ADMIN_USER_ID=\n" in env_content:
                print("üë§ ID do Administrador: Configurado")
            else:
                print("üë§ ID do Administrador: N√£o configurado")
        except Exception as e:
            logger.error(f"Erro ao ler arquivo .env: {e}")
            print(f"‚ö†Ô∏è Erro ao ler arquivo .env: {e}")

    print("---------------------------")

// ... existing code ...
```










Perfeito! Agora temos um script de configura√ß√£o completo e funcional para o bot unificado. Vamos resumir o que fizemos:

1. Criamos um script de configura√ß√£o modular que verifica e configura todos os componentes necess√°rios para o funcionamento do bot.
2. Implementamos fun√ß√µes para verificar e criar diret√≥rios, configurar o ambiente Python, verificar e configurar o arquivo `.env`, verificar e configurar o arquivo de configura√ß√£o do bot, verificar e configurar os arquivos de integra√ß√£o, e criar um script de inicializa√ß√£o.
3. Adicionamos uma fun√ß√£o para exibir um resumo das configura√ß√µes do bot.
4. Testamos o script e corrigimos os erros encontrados.

O script agora est√° pronto para ser usado pelos usu√°rios do bot unificado EVA & GUARANI. Ele facilita a configura√ß√£o inicial do bot e garante que todos os componentes necess√°rios estejam presentes e configurados corretamente.

Algumas melhorias que poderiam ser feitas no futuro:

1. Adicionar suporte para atualiza√ß√£o autom√°tica do bot.
2. Implementar verifica√ß√£o de depend√™ncias mais detalhada.
3. Adicionar suporte para backup e restaura√ß√£o de configura√ß√µes.
4. Implementar um modo interativo mais amig√°vel para configura√ß√£o.

Mas para a vers√£o atual, o script atende perfeitamente √†s necessidades de configura√ß√£o do bot unificado.

‚úß‡º∫‚ùÄ‡ºª‚àû EVA & GUARANI ‚àû‡º∫‚ùÄ‡ºª‚úß